Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.

The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.

Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.

But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.

Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key—album ID—for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.

At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_* and is the table where the primary-key is embedded in its value.  So the *_left-side-table_*  always provides the `ForiegnKeyExtractor` function.

The `albums` table is the *_right-side-table_* and always has the `primary-key` for the join. So, if you tried `albums.join(trackPurchases..)` the join would never work as the `albums` table has no knowlege of the `trackPurchases` table details.

If you have a situation where you have two tables where the primary-keys don't match, but *_each_* table has reference to each other's primary key, the the order of the tables in the join method won't matter.  But that scenario seems unlikely in practice.

With the track purchases table and the album table in hand, all that remains is to join them using the `join()` method. It's a wonderfully simply one-liner, but we have concealed a bit of complexity in the form of the `MusicInterestJoiner` class. More on that in a moment.

+++++
<pre class="snippet"><code class="java">{% include_raw tutorials/fk-joins/kstreams/code/src/main/java/io/confluent/developer/FkJoinTableToTable.java %}</code></pre>
+++++
