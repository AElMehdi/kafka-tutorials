Given a topic of click events on a website there are various ways that we can process it. As well as simply counting the number clicks in a regular time frame (hopping or tumbling windows) we can also perform sessionization on the data. Here the length of the time window is based on the concept of a session, which is defined based on a period of inactivity. A given user might visit a website multiple times a day, but in distinct visits. We can analyse how many clicks as well as the duration of each of these sessions. 

The first thing we'll do is create and populate the stream of click data. An important characteristic of this data is the _timestamp_ because this is what drives the session window. KSQL can use either the Kafka message timestamp, or a field from the message value as the timestamp. 

Create the stream: 

CREATE STREAM clicks (ip VARCHAR, url VARCHAR, timestamp VARCHAR)
WITH (KAFKA_TOPIC='clicks',
      KEY='ip',
      TIMESTAMP='timestamp',
      TIMESTAMP_FORMAT='yyyy-MM-dd''T''HH:mm:ssX',
      PARTITIONS=1,
      VALUE_FORMAT='Avro');

Once the stream is created, insert some data to it: 

INSERT INTO clicks (ip, url, timestamp) VALUES ('51.56.119.117','/etiam/justo/etiam/pretium/iaculis.xml','2019-07-18T10:00:00Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('51.56.119.117','/nullam/orci/pede/venenatis.json','2019-07-18T10:01:00Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('51.56.119.117','/convallis/nunc/proin.jsp','2019-07-18T10:01:30Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('53.170.33.192','/mauris/morbi/non.jpg','2019-07-18T10:01:31Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('53.170.33.192','/vestibulum/vestibulum/ante/ipsum/primis/in.json','2019-07-18T10:02:00Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('164.14.32.113','/auctor/sed/tristique.js','2019-07-18T11:00:00Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('51.56.119.117','/vehicula/consequat/morbi/a/ipsum/integer/a.jpg','2019-07-18T11:03:21Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('51.56.119.117','/pede/venenatis.jsp','2019-07-18T11:03:50Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('53.170.33.192','/nec/euismod/scelerisque/quam.xml','2019-07-18T11:40:00Z');
INSERT INTO clicks (ip, url, timestamp) VALUES ('53.170.33.192','/ligula/nec/sem/duis.jsp','2019-07-18T11:40:09Z');

Now that you have stream with some events in it, let's start to use them. The first thing that we'll do is ensure that the timestamp that KSQL will use for our time-based aggregation is the one that we expect. KSQL's timestamp is exposed as a column called `ROWTIME` and we can compare this to our declared `timestamp` column; they should match.  

Before checking the timestamps, set the following properties to ensure that you're reading from the beginning of the stream:

SET 'auto.offset.reset' = 'earliest';
SET 'ksql.streams.cache.max.bytes.buffering'='20000';

Now compare the timestamp we want to use (`timestamp` column) with the system column exposing how KSQL sees the timestamp (`ROWTIME`): 

SELECT TIMESTAMPTOSTRING(ROWTIME,'yyyy-MM-dd HH:mm:ss'), TIMESTAMP FROM CLICKS LIMIT 5;

2019-07-18 10:00:00 | 2019-07-18T10:00:00Z
2019-07-18 10:01:00 | 2019-07-18T10:01:00Z
2019-07-18 10:01:30 | 2019-07-18T10:01:30Z
2019-07-18 10:01:31 | 2019-07-18T10:01:31Z
2019-07-18 10:02:00 | 2019-07-18T10:02:00Z

You should see that both columns match in time value (only the formatting differs). 

Now let's see how many clicks were made in each user session (based on IP address), and also calculate the duration of the session. To do that, we issue the following transient query to aggregate the clicks grouped by the IP address. We declare that we want to use session windowing, with a gap of five minutes or more denoting the end of the previous session. It also captures the window start and end times, and uses these to calculate the session duration. The following will block and continue to return results until its limit is reached or you tell it to stop.

SELECT IP, 
       TIMESTAMPTOSTRING(windowstart(),'yyyy-MM-dd HH:mm:ss') AS SESSION_START_TS, 
       TIMESTAMPTOSTRING(windowend(),'yyyy-MM-dd HH:mm:ss')   AS SESSION_END_TS, 
       COUNT(*)                                               AS CLICK_COUNT, 
       WINDOWEND() - WINDOWSTART()                            AS SESSION_LENGTH_MS 
  FROM CLICKS 
       WINDOW SESSION (5 MINUTES) 
GROUP BY IP
LIMIT 5;

51.56.119.117 | 2019-07-18 10:00:00 | 2019-07-18 10:01:30 | 3 | 90000
53.170.33.192 | 2019-07-18 10:01:31 | 2019-07-18 10:02:00 | 2 | 29000
164.14.32.113 | 2019-07-18 11:00:00 | 2019-07-18 11:00:00 | 1 | 0
51.56.119.117 | 2019-07-18 11:03:21 | 2019-07-18 11:03:50 | 2 | 29000
53.170.33.192 | 2019-07-18 11:40:00 | 2019-07-18 11:40:09 | 2 | 9000

When KSQL builds aggregates it emits the values as new messages are processed, meaning that you may see intermediate results on the screen too. When `ksql.streams.cache.max.bytes.buffering` was set above this suppressed these; if you change the value to zero and re-run the above query you'll see the intermediate emissions too: 

SET 'ksql.streams.cache.max.bytes.buffering'='0';
SELECT IP, 
       TIMESTAMPTOSTRING(windowstart(),'yyyy-MM-dd HH:mm:ss') AS SESSION_START_TS, 
       TIMESTAMPTOSTRING(windowend(),'yyyy-MM-dd HH:mm:ss')   AS SESSION_END_TS, 
       COUNT(*)                                               AS CLICK_COUNT, 
       WINDOWEND() - WINDOWSTART()                            AS SESSION_LENGTH_MS 
  FROM CLICKS 
       WINDOW SESSION (5 MINUTES) 
GROUP BY IP
LIMIT 10;

51.56.119.117 | 2019-07-18 10:00:00 | 2019-07-18 10:00:00 | 1 | 0
51.56.119.117 | 2019-07-18 10:00:00 | 2019-07-18 10:01:00 | 2 | 60000
51.56.119.117 | 2019-07-18 10:00:00 | 2019-07-18 10:01:30 | 3 | 90000
53.170.33.192 | 2019-07-18 10:01:31 | 2019-07-18 10:01:31 | 1 | 0
53.170.33.192 | 2019-07-18 10:01:31 | 2019-07-18 10:02:00 | 2 | 29000
164.14.32.113 | 2019-07-18 11:00:00 | 2019-07-18 11:00:00 | 1 | 0
51.56.119.117 | 2019-07-18 11:03:21 | 2019-07-18 11:03:21 | 1 | 0
51.56.119.117 | 2019-07-18 11:03:21 | 2019-07-18 11:03:50 | 2 | 29000
53.170.33.192 | 2019-07-18 11:40:00 | 2019-07-18 11:40:00 | 1 | 0
53.170.33.192 | 2019-07-18 11:40:00 | 2019-07-18 11:40:09 | 2 | 9000

Now let's take this snapshot, and persist it as a table, populated continually by the results of the ongoing query: 

CREATE TABLE IP_SESSIONS AS
SELECT IP, 
       TIMESTAMPTOSTRING(windowstart(),'yyyy-MM-dd HH:mm:ss') AS SESSION_START_TS, 
       TIMESTAMPTOSTRING(windowend(),'yyyy-MM-dd HH:mm:ss')   AS SESSION_END_TS, 
       COUNT(*)                                               AS CLICK_COUNT, 
       WINDOWEND() - WINDOWSTART()                            AS SESSION_LENGTH_MS 
  FROM CLICKS 
       WINDOW SESSION (5 MINUTES) 
GROUP BY IP;

This creates and populate a table that we could query with a `SELECT`, but also a Kafka topic, which we can examine from within KSQL using `PRINT`. Notice that the key for each message contains some strange characters that aren't quite printable. KSQL has combined the grouping key (IP address) with its window boundaries using a format that's not quite printable in this format. It should look something like this:

ksql> print IP_SESSIONS limit 5;
Format:AVRO
7/18/19 10:01:30 AM UTC, 51.56.119.117l���l�5, {"IP": "51.56.119.117", "SESSION_START_TS": "2019-07-18 10:00:00", "SESSION_END_TS": "2019-07-18 10:01:30", "CLICK_COUNT": 3, "SESSION_LENGTH_MS": 90000}
7/18/19 10:02:00 AM UTC, 153.170.33.192l�       �l��x, {"IP": "153.170.33.192", "SESSION_START_TS": "2019-07-18 10:01:31", "SESSION_END_TS": "2019-07-18 10:02:00", "CLICK_COUNT": 2, "SESSION_LENGTH_MS": 29000}
7/18/19 11:00:00 AM UTC, 164.14.32.113l�#�l�#�, {"IP": "164.14.32.113", "SESSION_START_TS": "2019-07-18 11:00:00", "SESSION_END_TS": "2019-07-18 11:00:00", "CLICK_COUNT": 1, "SESSION_LENGTH_MS": 0}
7/18/19 11:03:50 AM UTC, 51.56.119.117l���l�4�, {"IP": "51.56.119.117", "SESSION_START_TS": "2019-07-18 11:03:21", "SESSION_END_TS": "2019-07-18 11:03:50", "CLICK_COUNT": 2, "SESSION_LENGTH_MS": 29000}
7/18/19 11:40:09 AM UTC, 153.170.33.192l��l�, {"IP": "153.170.33.192", "SESSION_START_TS": "2019-07-18 11:40:00", "SESSION_END_TS": "2019-07-18 11:40:09", "CLICK_COUNT": 2, "SESSION_LENGTH_MS": 9000}
ksql>



