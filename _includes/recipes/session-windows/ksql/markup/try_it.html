<div class="recipe-try-it-step">
  <h4 class="subtitle">
    <div>1. Initialize the project</div>
  </h4>

  <p>To get started, make a new directory anywhere you'd like for this project:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/init.sh %}</code></pre>

  <p>Then make the following directories to set up its structure:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/make-dirs.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle">
    <div>2. Get Confluent Platform</div>
  </h4>

  <p>Next, create the following <code>docker-compose.yml</code> file to obtain Confluent Platform:</p>
  <pre class="snippet"><code class="dockerfile">{% include_raw recipes/session-windows/ksql/code/docker-compose.yml %}</code></pre>

  <p>And launch it by running:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/docker-compose-up.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle">
    <div>3. Start the CLI and produce events to the input stream</div>
  </h4>

  <p>To begin developing interactively, open up the KSQL CLI:<p/>
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/start-cli.sh %}</code></pre>

  <p>The first thing we'll do is create and populate the stream of click data. An important characteristic of this data is the <em>timestamp</em> because this is what drives the session window. KSQL can use either the Kafka message timestamp, or a field from the message value as the timestamp. In this example we'll use the latterâ€”the <em>event time</em> as stored in the <code>timestamp</code> field of the message value.</p>
  <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/create-inputs.sql %}</code></pre>

  <p>Once the stream is created, insert some data to it. Note how the timestamps show how there are different sessions for each IP address.</p>
  <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/populate-stream.sql %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle">
    <div>4. Create a continuous query</div>
  </h4>

  <p>Now that you have stream with some events in it, let's start to use them. The first thing that we'll do is ensure that the timestamp that KSQL will use for our time-based aggregation is the one that we expect. KSQL's timestamp is exposed as a column called <code>ROWTIME</code> and we can compare this to our declared <code>timestamp</code> column; they should match. </p>
  <p>Before checking the timestamps, set the following property to ensure that you're reading from the beginning of the stream:
    <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/set-properties_offset.sql %}</code></pre>
  </p>

<p>Now compare the timestamp we want to use (<code>timestamp</code> column) with the system column exposing how KSQL sees the timestamp (<code>ROWTIME</code>): 
  <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/check-rowtime.sql %}</code></pre></p>
  
  <p>
  You should see that both columns match in time value (only the formatting differs):
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/outputs/check-rowtime/output-0.log %}</code></pre>

</p>

  <p>Now let's see how many clicks were made in each user session (based on IP address), and also calculate the duration of the session. To do that, we issue the following transient query to aggregate the clicks grouped by the IP address. We declare that we want to use session windowing, with a gap of five minutes or more denoting the end of the previous session. It also captures the window start and end times, and uses these to calculate the session duration. </p>
    <p>
      For the purposes of this example only, we are also going to configure KSQL to buffer the aggregates as it builds them. This makes the query feel like it responds more slowly, but means that you get just one row per window from which is simpler to understand the concept: 
      
      <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/set-properties_cache.sql %}</code></pre>
    </p>

    <p>
      The following will block and continue to return results until its limit is reached or you tell it to stop.</p>
  <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/transient-window.sql %}</code></pre>
  </p>

  <p>This should yield the following output:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/outputs/transient-window/output-0.log %}</code></pre>

  <p>When KSQL builds aggregates it emits the values as new messages are processed, meaning that you may see intermediate results on the screen too. When <code>ksql.streams.cache.max.bytes.buffering</code> was set above this suppressed these; if you change the value to zero and re-run the above query you'll see the intermediate emissions too: 
    <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/transient-window-no-buffer.sql %}</code></pre>
  </p>
<p>This time you'll see each aggregate update and be re-emitted as new messages are processed:
  <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/outputs/transient-window-no-buffer/output-0.log %}</code></pre>
</p>


<p>Now let's take this snapshot, and persist it as a table, populated continually by the results of the ongoing query:  
    <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/create-table.sql %}</code></pre>
</p>

<p>This creates and populate a table that we could query with a <code>SELECT</code>, but also a Kafka topic, which we can examine from within KSQL using <code>PRINT</code>.
  <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/print-topic.sql %}</code></pre>
   Notice that the key for each message contains some strange characters that aren't quite printable. KSQL has combined the grouping key (IP address) with its window boundaries using a format that's not quite printable in this format. It should look something like this:
   <pre class="snippet"><code class="shell">{% include_raw recipes/session-windows/ksql/code/recipe-steps/dev/outputs/print-topic/output-0.log %}</code></pre>  </p>


</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle"><div>5. Write your statements to a file</div></h4>

  <p>Now that you have a series of statements that's doing the right thing, the last step is to put them into a file so that they can be used outside the CLI session. Create a file at <code>src/statements.sql</code> with the following content:</p>
  <pre class="snippet"><code class="sql">{% include_raw recipes/session-windows/ksql/code/src/statements.sql %}</code></pre>
</div>
